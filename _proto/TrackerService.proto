syntax="proto3";

package MyTorrent;

option java_multiple_files = true;
option java_package = "mytorrent.grpc.trackerservice";
option java_outer_classname = "TrackerServiceProto";

message NetworkInfoRequest
{
}

message NetworkInfoResponse
{
    int64 FragmentSize = 1;
	string HashAlgorithm = 2;
    repeated string TorrentServer = 3;
}

message UploadStatusRequest
{
    string FileHash = 1;
}

enum UploadStatus {
    Initiated = 0;		//File Upload was initiated. No fragment was uploaded so far.
    Uploading = 1;		//File is uploading. Some fragments have already arrived.
    Canceled = 2;		//File Upload was canceled for some reason.
    Validating = 3;     //All fragments are uploaded, but the Server still validating the data before distributing it. 
    Distributing = 4;	//The fragments are currently distributed to the torrent servers.
    Distributed = 5;	//All fragments are distributed to the torrent servers.
	Unknown = 6;		//File is Unknown.
}

message UploadStatusResponse
{
    UploadStatus Status = 1;
}

message FileFragment
{
	string FileHash = 1;
    string FragmentHash = 2;
    bytes Data = 3;
}

message FileUploadInitiationRequest
{
    string FileHash = 1;
    int64 FileSize = 2;
}

message FileUploadInitiationResponse
{
}

message FragmentHolderList
{
	repeated string EndPoints = 1;
}

message FileUploadResponse
{
    map<string, FragmentHolderList> FragmentDistribution = 1;
}

service TrackerService
{
    rpc GetNetworkInfo(NetworkInfoRequest) returns (NetworkInfoResponse);
    rpc GetUploadStatus(UploadStatusRequest) returns (UploadStatusResponse);
    rpc InitiateUpload(FileUploadInitiationRequest) returns (FileUploadInitiationResponse);
	rpc UploadFileFragments(stream FileFragment) returns (FileUploadResponse);
}



message FileDistributionRequest
{
    //The hash of the file you want to download
    string FileHash = 1;
}

message FileDistributionResponse
{
    /* List of strings where each string is the hash of one fragment. The order of the list equals the order in which the
     * fragment have to be put together after downloading to get the original file.
     */
	  repeated string FragmentOrder = 1;
    // Dictionary where for each fragment hash exists a list uris for the torrents holding this fragment.
    map<string, FragmentHolderList> FragmentDistribution = 2;
}

message FragmentDownloadRequest
{
    // Hash of the fragment you want to download.
    string FragmentHash = 1;
}

message FragmentDownloadResponse
{
    // Byte date of the fragment you just download.
    bytes Data = 1;
}

// Interface between the client and the torrent servers holding the data
service TorrentService
{
    /* Service that gives you for a specifik file the locations of all fragments in the torrent network
     * and their order to join the back together.
     */
    rpc GetFileDistribution(FileDistributionRequest) returns (FileDistributionResponse);
    
    // Services that provides the byte data of the fragment, you requested by the hash string     
    rpc DownloadFileFragment(stream FragmentDownloadRequest) returns (stream FragmentDownloadResponse);
}